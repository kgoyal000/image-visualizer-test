<!DOCTYPE html>
<html>
<head>
    <title>Realistic Photo Frame Viewer</title>
    <style>
        body { margin: 0; background: #f0f0f0; }
        canvas { display: block; }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 100;
            font-family: Arial, sans-serif;
        }
        #status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            background: white;
            padding: 10px 20px;
            border-radius: 4px;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-btn {
            margin-top: 10px;
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="imageUpload" accept="image/*">
        <button class="control-btn" id="resetPosition">Reset View</button>
    </div>
    <div id="status">Loading...</div>
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        window.addEventListener('load', () => {
            let scene, camera, renderer, frame;
            const status = document.getElementById('status');
            let targetRotationX = -0.1;
            let targetRotationY = 0.3;
            let isDragging = false;

            function init() {
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);

                // Camera setup
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 5);
                camera.lookAt(0, 0, 0);

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // Lighting setup
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);

                const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
                mainLight.position.set(2, 5, 3);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 1024;
                mainLight.shadow.mapSize.height = 1024;
                scene.add(mainLight);

                // Floor setup
                const floorGeometry = new THREE.PlaneGeometry(20, 20);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xdddddd,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                scene.add(floor);

                // Event listeners
                setupEventListeners();
                createPhotoFrame('https://thestackhouse.com/cdn/shop/files/article1_840x560.webp?v=1728383842');
            }

            function setupEventListeners() {
                // File upload
                document.getElementById('imageUpload').addEventListener('change', handleFileUpload);
                
                // Reset view
                document.getElementById('resetPosition').addEventListener('click', () => {
                    targetRotationX = -0.1;
                    targetRotationY = 0.3;
                });

                // Mouse controls
                const onMouseDown = (e) => {
                    isDragging = true;
                    renderer.domElement.style.cursor = 'grabbing';
                };

                const onMouseUp = () => {
                    isDragging = false;
                    renderer.domElement.style.cursor = 'grab';
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    
                    targetRotationY += e.movementX * 0.005;
                    targetRotationX += e.movementY * 0.005;
                };

                renderer.domElement.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mouseup', onMouseUp);
                document.addEventListener('mousemove', onMouseMove);
                window.addEventListener('resize', onWindowResize);
                renderer.domElement.style.cursor = 'grab';
            }

            function createPhotoFrame(imageUrl) {
                status.style.display = 'block';
                status.textContent = 'Loading image...';

                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(
                    imageUrl,
                    (texture) => {
                        if (frame) scene.remove(frame);
                        
                        const aspectRatio = texture.image.width / texture.image.height;
                        const maxWidth = 4; // Maximum width of the frame
                        const maxHeight = 4; // Maximum height of the frame

                        // Adjust frame dimensions to fit the screen
                        let frameWidth, frameHeight;
                        if (aspectRatio > 1) {
                            frameWidth = maxWidth;
                            frameHeight = maxWidth / aspectRatio;
                        } else {
                            frameHeight = maxHeight;
                            frameWidth = maxHeight * aspectRatio;
                        }

                        const frameDepth = 0.15;
                        const borderSize = 0.15;

                        frame = new THREE.Group();
                        frame.position.set(0, 0, 0);

                        // Main image
                        const imageGeometry = new THREE.PlaneGeometry(frameWidth, frameHeight);
                        const imageMaterial = new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            roughness: 0.7,
                            metalness: 0.1
                        });
                        const imageMesh = new THREE.Mesh(imageGeometry, imageMaterial);
                        imageMesh.position.z = 0.01;
                        imageMesh.castShadow = true;
                        frame.add(imageMesh);

                        // Frame material
                        const frameMaterial = new THREE.MeshStandardMaterial({
                            color: 0x5a432e,
                            roughness: 0.6,
                            metalness: 0.3
                        });

                        // Frame borders
                        const addBorder = (width, height, depth, position) => {
                            const border = new THREE.Mesh(
                                new THREE.BoxGeometry(width, height, depth),
                                frameMaterial
                            );
                            border.position.copy(position);
                            border.castShadow = true;
                            frame.add(border);
                        };

                        // Top border
                        addBorder(
                            frameWidth + borderSize * 2,
                            borderSize,
                            frameDepth,
                            new THREE.Vector3(0, frameHeight/2 + borderSize/2, 0)
                        );

                        // Bottom border
                        addBorder(
                            frameWidth + borderSize * 2,
                            borderSize,
                            frameDepth,
                            new THREE.Vector3(0, -frameHeight/2 - borderSize/2, 0)
                        );

                        // Side borders
                        addBorder(
                            borderSize,
                            frameHeight,
                            frameDepth,
                            new THREE.Vector3(-frameWidth/2 - borderSize/2, 0, 0)
                        );
                        addBorder(
                            borderSize,
                            frameHeight,
                            frameDepth,
                            new THREE.Vector3(frameWidth/2 + borderSize/2, 0, 0)
                        );

                        // Back panel
                        const backPanel = new THREE.Mesh(
                            new THREE.BoxGeometry(
                                frameWidth + borderSize * 2,
                                frameHeight + borderSize * 2,
                                0.05
                            ),
                            new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                        );
                        backPanel.position.z = -frameDepth/2;
                        backPanel.castShadow = true;
                        frame.add(backPanel);

                        scene.add(frame);

                        // Adjust camera to fit the frame
                        adjustCameraToFitFrame(frameWidth, frameHeight);

                        status.style.display = 'none';
                    },
                    undefined,
                    (error) => {
                        status.textContent = 'Error loading image';
                        console.error(error);
                    }
                );
            }

            function adjustCameraToFitFrame(frameWidth, frameHeight) {
                // Calculate the distance required to fit the frame in the viewport
                const maxDimension = Math.max(frameWidth, frameHeight);
                const fov = camera.fov * (Math.PI / 180); // Convert FOV to radians
                const distance = Math.abs(maxDimension / Math.sin(fov / 2));

                // Position the camera
                camera.position.z = distance * 1.2; // Add a little extra space
                camera.lookAt(0, 0, 0);
            }

            function handleFileUpload(e) {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    createPhotoFrame(url);
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);

                // Re-adjust camera if frame exists
                if (frame) {
                    const frameWidth = frame.children[0].geometry.parameters.width;
                    const frameHeight = frame.children[0].geometry.parameters.height;
                    adjustCameraToFitFrame(frameWidth, frameHeight);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                
                // Smooth rotation
                if (frame) {
                    frame.rotation.x += (targetRotationX - frame.rotation.x) * 0.1;
                    frame.rotation.y += (targetRotationY - frame.rotation.y) * 0.1;
                }

                renderer.render(scene, camera);
            }

            init();
            animate();
        });
    </script>
</body>
</html>
